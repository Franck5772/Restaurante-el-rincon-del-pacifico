"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ultravox-client@0.3.2";
exports.ids = ["vendor-chunks/ultravox-client@0.3.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/ultravox-client@0.3.2/node_modules/ultravox-client/dist/esm/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ultravox-client@0.3.2/node_modules/ultravox-client/dist/esm/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Medium: () => (/* binding */ Medium),\n/* harmony export */   Role: () => (/* binding */ Role),\n/* harmony export */   Transcript: () => (/* binding */ Transcript),\n/* harmony export */   UltravoxExperimentalMessageEvent: () => (/* binding */ UltravoxExperimentalMessageEvent),\n/* harmony export */   UltravoxSession: () => (/* binding */ UltravoxSession),\n/* harmony export */   UltravoxSessionStatus: () => (/* binding */ UltravoxSessionStatus),\n/* harmony export */   UltravoxSessionStatusChangedEvent: () => (/* binding */ UltravoxSessionStatusChangedEvent),\n/* harmony export */   UltravoxTranscriptsChangedEvent: () => (/* binding */ UltravoxTranscriptsChangedEvent)\n/* harmony export */ });\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! livekit-client */ \"(ssr)/./node_modules/.pnpm/livekit-client@2.5.2/node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n\n/* The current status of an UltravoxSession. */\nvar UltravoxSessionStatus;\n(function (UltravoxSessionStatus) {\n    /* The session is not connected and not attempting to connect. This is the initial state. */\n    UltravoxSessionStatus[\"DISCONNECTED\"] = \"disconnected\";\n    /* The client is disconnecting from the session. */\n    UltravoxSessionStatus[\"DISCONNECTING\"] = \"disconnecting\";\n    /* The client is attempting to connect to the session. */\n    UltravoxSessionStatus[\"CONNECTING\"] = \"connecting\";\n    /* The client is connected to the session and the server is warming up. */\n    UltravoxSessionStatus[\"IDLE\"] = \"idle\";\n    /* The client is connected and the server is listening for voice input. */\n    UltravoxSessionStatus[\"LISTENING\"] = \"listening\";\n    /* The client is connected and the server is considering its response. The user can still interrupt. */\n    UltravoxSessionStatus[\"THINKING\"] = \"thinking\";\n    /* The client is connected and the server is playing response audio. The user can interrupt as needed. */\n    UltravoxSessionStatus[\"SPEAKING\"] = \"speaking\";\n})(UltravoxSessionStatus || (UltravoxSessionStatus = {}));\n/* The participant responsible for an utterance. */\nvar Role;\n(function (Role) {\n    Role[\"USER\"] = \"user\";\n    Role[\"AGENT\"] = \"agent\";\n})(Role || (Role = {}));\n/* How a message was communicated. */\nvar Medium;\n(function (Medium) {\n    Medium[\"VOICE\"] = \"voice\";\n    Medium[\"TEXT\"] = \"text\";\n})(Medium || (Medium = {}));\n/** A transcription of a single utterance. */\nclass Transcript {\n    text;\n    isFinal;\n    speaker;\n    medium;\n    constructor(\n    /* The possibly-incomplete text of an utterance. */\n    text, \n    /* Whether the text is complete or the utterance is ongoing. */\n    isFinal, \n    /* Who emitted the utterance. */\n    speaker, \n    /* The medium through which the utterance was emitted. */\n    medium) {\n        this.text = text;\n        this.isFinal = isFinal;\n        this.speaker = speaker;\n        this.medium = medium;\n    }\n}\n/* Event emitted by an UltravoxSession when its status changes. */\nclass UltravoxSessionStatusChangedEvent extends Event {\n    constructor() {\n        super('status');\n    }\n}\n/* Event emitted by an UltravoxSession when its transcripts change. */\nclass UltravoxTranscriptsChangedEvent extends Event {\n    constructor() {\n        super('transcripts');\n    }\n}\n/* Event emitted by an UltravoxSession when an experimental message is received. */\nclass UltravoxExperimentalMessageEvent extends Event {\n    message;\n    constructor(message) {\n        super('experimental_message');\n        this.message = message;\n    }\n}\n/**\n * Manages a single session with Ultravox and emits events to notify consumers of\n * state changes. The following events are emitted:\n *\n * - status: The status of the session has changed.\n * - transcripts: A transcript was added or updated.\n * - experimental_message: An experimental message was received. The message is included in the event.\n *\n */\nclass UltravoxSession extends EventTarget {\n    static CONNECTED_STATUSES = new Set([\n        UltravoxSessionStatus.LISTENING,\n        UltravoxSessionStatus.THINKING,\n        UltravoxSessionStatus.SPEAKING,\n    ]);\n    _transcripts = [];\n    _status = UltravoxSessionStatus.DISCONNECTED;\n    registeredTools = new Map();\n    socket;\n    room;\n    audioElement = new Audio();\n    localAudioTrack;\n    micSourceNode;\n    agentSourceNode;\n    delayedSpeakingState = false;\n    textDecoder = new TextDecoder();\n    textEncoder = new TextEncoder();\n    audioContext;\n    experimentalMessages;\n    _isMicMuted = false;\n    _isSpeakerMuted = false;\n    /**\n     * Constructor for UltravoxSession.\n     * @param audioContext An AudioContext to use for audio processing. If not provided, a new AudioContext will be created.\n     * @param experimentalMessages A set of experimental message types to enable. Empty by default.\n     */\n    constructor({ audioContext, experimentalMessages, } = {}) {\n        super();\n        this.audioContext = audioContext || new AudioContext();\n        this.experimentalMessages = experimentalMessages || new Set();\n    }\n    /** Returns all transcripts for the current session. */\n    get transcripts() {\n        return [...this._transcripts];\n    }\n    /** Returns the session's current status. */\n    get status() {\n        return this._status;\n    }\n    /**\n     * Indicates whether the user's mic is currently muted for the session. (Does not inspect\n     * hardware state.)\n     */\n    get isMicMuted() {\n        return this._isMicMuted;\n    }\n    /**\n     * Indicates whether the user's speaker (e.g. agent output audio) is currently muted for the\n     * session. (Does not inspect system volume or hardware state.)\n     */\n    get isSpeakerMuted() {\n        return this._isSpeakerMuted;\n    }\n    /**\n     * Registers a client tool implementation with the given name. If the call is\n     * started with a client-implemented tool, this implementation will be invoked\n     * when the model calls the tool.\n     *\n     * See https://docs.ultravox.ai/tools for more information.\n     */\n    registerToolImplementation(name, implementation) {\n        this.registeredTools.set(name, implementation);\n    }\n    /** Convenience batch wrapper for registerToolImplementation. */\n    registerToolImplementations(implementationMap) {\n        for (const [name, implementation] of Object.entries(implementationMap)) {\n            this.registerToolImplementation(name, implementation);\n        }\n    }\n    /** Connects to a call using the given joinUrl. */\n    joinCall(joinUrl) {\n        if (this._status !== UltravoxSessionStatus.DISCONNECTED) {\n            throw new Error('Cannot join a new call while already in a call');\n        }\n        if (this.experimentalMessages) {\n            const url = new URL(joinUrl);\n            url.searchParams.set('experimentalMessages', Array.from(this.experimentalMessages.values()).join(','));\n            joinUrl = url.toString();\n        }\n        this.setStatus(UltravoxSessionStatus.CONNECTING);\n        this.socket = new WebSocket(joinUrl);\n        this.socket.onmessage = (event) => this.handleSocketMessage(event);\n        this.socket.onclose = (event) => this.handleSocketClose(event);\n    }\n    /** Leaves the current call (if any). */\n    async leaveCall() {\n        await this.disconnect();\n    }\n    /**\n     * Sets the agent's output medium. If the agent is currently speaking, this will take effect at\n     * the end of the agent's utterance. Also see muteSpeaker and unmuteSpeaker below.\n     */\n    setOutputMedium(medium) {\n        if (!UltravoxSession.CONNECTED_STATUSES.has(this._status)) {\n            throw new Error(`Cannot set output medium while not connected. Current status is ${this._status}.`);\n        }\n        this.sendData({ type: 'set_output_medium', medium });\n    }\n    /** Sends a message via text. */\n    sendText(text) {\n        if (!UltravoxSession.CONNECTED_STATUSES.has(this._status)) {\n            throw new Error(`Cannot send text while not connected. Current status is ${this._status}.`);\n        }\n        this.sendData({ type: 'input_text_message', text });\n    }\n    /** Mutes audio input from the user. */\n    muteMic() {\n        if (!this.room?.localParticipant) {\n            throw new Error('Cannot muteMic.');\n        }\n        this._isMicMuted = true;\n        this.room.localParticipant.setMicrophoneEnabled(false);\n    }\n    /** Unmutes audio input from the user. */\n    unmuteMic() {\n        if (!this.room?.localParticipant) {\n            throw new Error('Cannot unmuteMic.');\n        }\n        this._isMicMuted = false;\n        this.room.localParticipant.setMicrophoneEnabled(true);\n    }\n    /** Toggles the mute state of the user's audio input. */\n    toggleMicMute() {\n        if (!this.room?.localParticipant) {\n            throw new Error('Cannot toggle mic mute.');\n        }\n        if (this.isMicMuted) {\n            this.unmuteMic();\n        }\n        else {\n            this.muteMic();\n        }\n    }\n    /** Mutes audio output from the agent. */\n    muteSpeaker() {\n        if (!this.room?.remoteParticipants) {\n            throw new Error('Cannot muteSpeaker.');\n        }\n        this._isSpeakerMuted = true;\n        this.room.remoteParticipants.forEach((participant) => {\n            participant.audioTrackPublications.forEach((publication) => {\n                publication.track?.setMuted(true);\n            });\n        });\n    }\n    /** Unmutes audio output from the agent. */\n    unmuteSpeaker() {\n        if (!this.room?.remoteParticipants) {\n            throw new Error('Cannot unmuteSpeaker.');\n        }\n        this._isSpeakerMuted = false;\n        this.room.remoteParticipants.forEach((participant) => {\n            participant.audioTrackPublications.forEach((publication) => {\n                publication.track?.setMuted(false);\n            });\n        });\n    }\n    /** Toggles the mute state of the agent's output audio. */\n    toggleSpeakerMute() {\n        if (!this.room?.remoteParticipants) {\n            throw new Error('Cannot toggle speaker mute.');\n        }\n        if (this.isSpeakerMuted) {\n            this.unmuteSpeaker();\n        }\n        else {\n            this.muteSpeaker();\n        }\n    }\n    async handleSocketMessage(event) {\n        const msg = JSON.parse(event.data);\n        // We attach the Livekit audio to an audio element so that we can mute the audio\n        // when the agent is not speaking. For now, disable Livekit's WebAudio mixing\n        // to avoid the audio playing twice:\n        //\n        // References:\n        //  - https://docs.livekit.io/guides/migrate-from-v1/#Javascript-Typescript\n        //  - https://github.com/livekit/components-js/pull/855\n        //\n        this.room = new livekit_client__WEBPACK_IMPORTED_MODULE_0__.Room({ webAudioMix: false });\n        this.room.on(livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackSubscribed, (track) => this.handleTrackSubscribed(track));\n        this.room.on(livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.DataReceived, (payload, participant) => this.handleDataReceived(payload, participant));\n        const [track, _] = await Promise.all([(0,livekit_client__WEBPACK_IMPORTED_MODULE_0__.createLocalAudioTrack)(), this.room.connect(msg.roomUrl, msg.token)]);\n        this.localAudioTrack = track;\n        this.localAudioTrack.setAudioContext(this.audioContext);\n        if ([UltravoxSessionStatus.DISCONNECTED, UltravoxSessionStatus.DISCONNECTING].includes(this.status)) {\n            // We've been stopped while waiting for the mic permission (during createLocalTracks).\n            await this.disconnect();\n            return;\n        }\n        this.audioContext.resume();\n        this.audioElement.play();\n        if (this.localAudioTrack.mediaStream) {\n            this.micSourceNode = this.audioContext.createMediaStreamSource(this.localAudioTrack.mediaStream);\n        }\n        const opts = { name: 'audio', simulcast: false, source: livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone };\n        this.room.localParticipant.publishTrack(this.localAudioTrack, opts);\n        this.setStatus(UltravoxSessionStatus.IDLE);\n    }\n    async handleSocketClose(event) {\n        await this.disconnect();\n    }\n    async disconnect() {\n        this.setStatus(UltravoxSessionStatus.DISCONNECTING);\n        this.localAudioTrack?.stop();\n        this.localAudioTrack = undefined;\n        await this.room?.disconnect();\n        this.room = undefined;\n        this.socket?.close();\n        this.socket = undefined;\n        this.micSourceNode?.disconnect();\n        this.micSourceNode = undefined;\n        this.agentSourceNode?.disconnect();\n        this.agentSourceNode = undefined;\n        this.audioElement.pause();\n        this.audioElement.srcObject = null;\n        this.setStatus(UltravoxSessionStatus.DISCONNECTED);\n    }\n    handleTrackSubscribed(track) {\n        const audioTrack = track;\n        audioTrack.attach(this.audioElement);\n        if (track.mediaStream) {\n            this.agentSourceNode = this.audioContext.createMediaStreamSource(track.mediaStream);\n        }\n        if (this.delayedSpeakingState) {\n            this.delayedSpeakingState = false;\n            this.setStatus(UltravoxSessionStatus.SPEAKING);\n        }\n    }\n    setStatus(status) {\n        if (this._status === status) {\n            return;\n        }\n        this._status = status;\n        this.dispatchEvent(new UltravoxSessionStatusChangedEvent());\n    }\n    sendData(obj) {\n        this.room?.localParticipant.publishData(this.textEncoder.encode(JSON.stringify(obj)), { reliable: true });\n    }\n    handleDataReceived(payload, _participant) {\n        const msg = JSON.parse(this.textDecoder.decode(payload));\n        if (msg.type === 'state') {\n            const newState = msg.state;\n            if (newState === UltravoxSessionStatus.SPEAKING && this.agentSourceNode === undefined) {\n                // Skip the first speaking state, before we've attached the audio element.\n                // handleTrackSubscribed will be called soon and will change the state.\n                this.delayedSpeakingState = true;\n            }\n            else {\n                this.setStatus(newState);\n            }\n        }\n        else if (msg.type === 'transcript') {\n            const medium = msg.transcript.medium == 'voice' ? Medium.VOICE : Medium.TEXT;\n            const transcript = new Transcript(msg.transcript.text, msg.transcript.final, Role.USER, medium);\n            this.addOrUpdateTranscript(transcript);\n        }\n        else if (msg.type === 'voice_synced_transcript' || msg.type == 'agent_text_transcript') {\n            const medium = msg.type == 'agent_text_transcript' ? Medium.TEXT : Medium.VOICE;\n            if (msg.text != null) {\n                const newTranscript = new Transcript(msg.text, msg.final, Role.AGENT, medium);\n                this.addOrUpdateTranscript(newTranscript);\n            }\n            else if (msg.delta != null) {\n                const lastTranscript = this._transcripts.length ? this._transcripts[this._transcripts.length - 1] : undefined;\n                if (lastTranscript && lastTranscript.speaker == Role.AGENT) {\n                    const newTranscript = new Transcript(lastTranscript.text + msg.delta, msg.final, Role.AGENT, medium);\n                    this.addOrUpdateTranscript(newTranscript);\n                }\n            }\n        }\n        else if (msg.type == 'client_tool_invocation') {\n            this.invokeClientTool(msg.toolName, msg.invocationId, msg.parameters);\n        }\n        else if (this.experimentalMessages) {\n            this.dispatchEvent(new UltravoxExperimentalMessageEvent(msg));\n        }\n    }\n    addOrUpdateTranscript(transcript) {\n        if (this._transcripts.length) {\n            const lastTranscript = this._transcripts[this._transcripts.length - 1];\n            if (lastTranscript && !lastTranscript.isFinal && transcript.speaker === lastTranscript.speaker) {\n                this._transcripts[this._transcripts.length - 1] = transcript;\n            }\n            else {\n                this._transcripts.push(transcript);\n            }\n        }\n        else {\n            this._transcripts.push(transcript);\n        }\n        this.dispatchEvent(new UltravoxTranscriptsChangedEvent());\n    }\n    invokeClientTool(toolName, invocationId, parameters) {\n        const tool = this.registeredTools.get(toolName);\n        if (!tool) {\n            this.sendData({\n                type: 'client_tool_result',\n                invocationId,\n                errorType: 'undefined',\n                errorMessage: `Client tool ${toolName} is not registered (TypeScript client)`,\n            });\n            return;\n        }\n        try {\n            const result = tool(parameters);\n            if (result instanceof Promise) {\n                result\n                    .then((result) => this.handleClientToolResult(invocationId, result))\n                    .catch((error) => this.handleClientToolFailure(invocationId, error));\n            }\n            else {\n                this.handleClientToolResult(invocationId, result);\n            }\n        }\n        catch (e) {\n            this.handleClientToolFailure(invocationId, e);\n        }\n    }\n    handleClientToolResult(invocationId, result) {\n        if (typeof result === 'string') {\n            this.sendData({ type: 'client_tool_result', invocationId, result });\n        }\n        else {\n            const resultString = result.result;\n            const responseType = result.responseType;\n            if (typeof resultString !== 'string' || typeof responseType !== 'string') {\n                this.sendData({\n                    type: 'client_tool_result',\n                    invocationId,\n                    errorType: 'implementation-error',\n                    errorMessage: 'Client tool result must be a string or an object with string \"result\" and \"responseType\" properties.',\n                });\n            }\n            else {\n                this.sendData({ type: 'client_tool_result', invocationId, result: resultString, responseType });\n            }\n        }\n    }\n    handleClientToolFailure(invocationId, error) {\n        this.sendData({\n            type: 'client_tool_result',\n            invocationId,\n            errorType: 'implementation-error',\n            errorMessage: error instanceof Error ? error.message : undefined,\n        });\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdWx0cmF2b3gtY2xpZW50QDAuMy4yL25vZGVfbW9kdWxlcy91bHRyYXZveC1jbGllbnQvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWdGO0FBQ2hGO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0NBQXNDLElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsYUFBYTtBQUM1RztBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsYUFBYTtBQUNwRztBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQUksR0FBRyxvQkFBb0I7QUFDbkQscUJBQXFCLHFEQUFTO0FBQzlCLHFCQUFxQixxREFBUztBQUM5Qiw4Q0FBOEMscUVBQXFCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5Q0FBeUMsaURBQUs7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxnQkFBZ0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrREFBa0Q7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdDQUFnQyw4RUFBOEU7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VsdHJhdm94LXR1dG9yaWFsLWNsaWVudC10b29scy8uL25vZGVfbW9kdWxlcy8ucG5wbS91bHRyYXZveC1jbGllbnRAMC4zLjIvbm9kZV9tb2R1bGVzL3VsdHJhdm94LWNsaWVudC9kaXN0L2VzbS9pbmRleC5qcz9iMTZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUxvY2FsQXVkaW9UcmFjaywgUm9vbSwgUm9vbUV2ZW50LCBUcmFjaywgfSBmcm9tICdsaXZla2l0LWNsaWVudCc7XG4vKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgYW4gVWx0cmF2b3hTZXNzaW9uLiAqL1xuZXhwb3J0IHZhciBVbHRyYXZveFNlc3Npb25TdGF0dXM7XG4oZnVuY3Rpb24gKFVsdHJhdm94U2Vzc2lvblN0YXR1cykge1xuICAgIC8qIFRoZSBzZXNzaW9uIGlzIG5vdCBjb25uZWN0ZWQgYW5kIG5vdCBhdHRlbXB0aW5nIHRvIGNvbm5lY3QuIFRoaXMgaXMgdGhlIGluaXRpYWwgc3RhdGUuICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiRElTQ09OTkVDVEVEXCJdID0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgICAvKiBUaGUgY2xpZW50IGlzIGRpc2Nvbm5lY3RpbmcgZnJvbSB0aGUgc2Vzc2lvbi4gKi9cbiAgICBVbHRyYXZveFNlc3Npb25TdGF0dXNbXCJESVNDT05ORUNUSU5HXCJdID0gXCJkaXNjb25uZWN0aW5nXCI7XG4gICAgLyogVGhlIGNsaWVudCBpcyBhdHRlbXB0aW5nIHRvIGNvbm5lY3QgdG8gdGhlIHNlc3Npb24uICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiQ09OTkVDVElOR1wiXSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIC8qIFRoZSBjbGllbnQgaXMgY29ubmVjdGVkIHRvIHRoZSBzZXNzaW9uIGFuZCB0aGUgc2VydmVyIGlzIHdhcm1pbmcgdXAuICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiSURMRVwiXSA9IFwiaWRsZVwiO1xuICAgIC8qIFRoZSBjbGllbnQgaXMgY29ubmVjdGVkIGFuZCB0aGUgc2VydmVyIGlzIGxpc3RlbmluZyBmb3Igdm9pY2UgaW5wdXQuICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiTElTVEVOSU5HXCJdID0gXCJsaXN0ZW5pbmdcIjtcbiAgICAvKiBUaGUgY2xpZW50IGlzIGNvbm5lY3RlZCBhbmQgdGhlIHNlcnZlciBpcyBjb25zaWRlcmluZyBpdHMgcmVzcG9uc2UuIFRoZSB1c2VyIGNhbiBzdGlsbCBpbnRlcnJ1cHQuICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiVEhJTktJTkdcIl0gPSBcInRoaW5raW5nXCI7XG4gICAgLyogVGhlIGNsaWVudCBpcyBjb25uZWN0ZWQgYW5kIHRoZSBzZXJ2ZXIgaXMgcGxheWluZyByZXNwb25zZSBhdWRpby4gVGhlIHVzZXIgY2FuIGludGVycnVwdCBhcyBuZWVkZWQuICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiU1BFQUtJTkdcIl0gPSBcInNwZWFraW5nXCI7XG59KShVbHRyYXZveFNlc3Npb25TdGF0dXMgfHwgKFVsdHJhdm94U2Vzc2lvblN0YXR1cyA9IHt9KSk7XG4vKiBUaGUgcGFydGljaXBhbnQgcmVzcG9uc2libGUgZm9yIGFuIHV0dGVyYW5jZS4gKi9cbmV4cG9ydCB2YXIgUm9sZTtcbihmdW5jdGlvbiAoUm9sZSkge1xuICAgIFJvbGVbXCJVU0VSXCJdID0gXCJ1c2VyXCI7XG4gICAgUm9sZVtcIkFHRU5UXCJdID0gXCJhZ2VudFwiO1xufSkoUm9sZSB8fCAoUm9sZSA9IHt9KSk7XG4vKiBIb3cgYSBtZXNzYWdlIHdhcyBjb21tdW5pY2F0ZWQuICovXG5leHBvcnQgdmFyIE1lZGl1bTtcbihmdW5jdGlvbiAoTWVkaXVtKSB7XG4gICAgTWVkaXVtW1wiVk9JQ0VcIl0gPSBcInZvaWNlXCI7XG4gICAgTWVkaXVtW1wiVEVYVFwiXSA9IFwidGV4dFwiO1xufSkoTWVkaXVtIHx8IChNZWRpdW0gPSB7fSkpO1xuLyoqIEEgdHJhbnNjcmlwdGlvbiBvZiBhIHNpbmdsZSB1dHRlcmFuY2UuICovXG5leHBvcnQgY2xhc3MgVHJhbnNjcmlwdCB7XG4gICAgdGV4dDtcbiAgICBpc0ZpbmFsO1xuICAgIHNwZWFrZXI7XG4gICAgbWVkaXVtO1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qIFRoZSBwb3NzaWJseS1pbmNvbXBsZXRlIHRleHQgb2YgYW4gdXR0ZXJhbmNlLiAqL1xuICAgIHRleHQsIFxuICAgIC8qIFdoZXRoZXIgdGhlIHRleHQgaXMgY29tcGxldGUgb3IgdGhlIHV0dGVyYW5jZSBpcyBvbmdvaW5nLiAqL1xuICAgIGlzRmluYWwsIFxuICAgIC8qIFdobyBlbWl0dGVkIHRoZSB1dHRlcmFuY2UuICovXG4gICAgc3BlYWtlciwgXG4gICAgLyogVGhlIG1lZGl1bSB0aHJvdWdoIHdoaWNoIHRoZSB1dHRlcmFuY2Ugd2FzIGVtaXR0ZWQuICovXG4gICAgbWVkaXVtKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuaXNGaW5hbCA9IGlzRmluYWw7XG4gICAgICAgIHRoaXMuc3BlYWtlciA9IHNwZWFrZXI7XG4gICAgICAgIHRoaXMubWVkaXVtID0gbWVkaXVtO1xuICAgIH1cbn1cbi8qIEV2ZW50IGVtaXR0ZWQgYnkgYW4gVWx0cmF2b3hTZXNzaW9uIHdoZW4gaXRzIHN0YXR1cyBjaGFuZ2VzLiAqL1xuZXhwb3J0IGNsYXNzIFVsdHJhdm94U2Vzc2lvblN0YXR1c0NoYW5nZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0YXR1cycpO1xuICAgIH1cbn1cbi8qIEV2ZW50IGVtaXR0ZWQgYnkgYW4gVWx0cmF2b3hTZXNzaW9uIHdoZW4gaXRzIHRyYW5zY3JpcHRzIGNoYW5nZS4gKi9cbmV4cG9ydCBjbGFzcyBVbHRyYXZveFRyYW5zY3JpcHRzQ2hhbmdlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigndHJhbnNjcmlwdHMnKTtcbiAgICB9XG59XG4vKiBFdmVudCBlbWl0dGVkIGJ5IGFuIFVsdHJhdm94U2Vzc2lvbiB3aGVuIGFuIGV4cGVyaW1lbnRhbCBtZXNzYWdlIGlzIHJlY2VpdmVkLiAqL1xuZXhwb3J0IGNsYXNzIFVsdHJhdm94RXhwZXJpbWVudGFsTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIG1lc3NhZ2U7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcignZXhwZXJpbWVudGFsX21lc3NhZ2UnKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG59XG4vKipcbiAqIE1hbmFnZXMgYSBzaW5nbGUgc2Vzc2lvbiB3aXRoIFVsdHJhdm94IGFuZCBlbWl0cyBldmVudHMgdG8gbm90aWZ5IGNvbnN1bWVycyBvZlxuICogc3RhdGUgY2hhbmdlcy4gVGhlIGZvbGxvd2luZyBldmVudHMgYXJlIGVtaXR0ZWQ6XG4gKlxuICogLSBzdGF0dXM6IFRoZSBzdGF0dXMgb2YgdGhlIHNlc3Npb24gaGFzIGNoYW5nZWQuXG4gKiAtIHRyYW5zY3JpcHRzOiBBIHRyYW5zY3JpcHQgd2FzIGFkZGVkIG9yIHVwZGF0ZWQuXG4gKiAtIGV4cGVyaW1lbnRhbF9tZXNzYWdlOiBBbiBleHBlcmltZW50YWwgbWVzc2FnZSB3YXMgcmVjZWl2ZWQuIFRoZSBtZXNzYWdlIGlzIGluY2x1ZGVkIGluIHRoZSBldmVudC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBVbHRyYXZveFNlc3Npb24gZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgc3RhdGljIENPTk5FQ1RFRF9TVEFUVVNFUyA9IG5ldyBTZXQoW1xuICAgICAgICBVbHRyYXZveFNlc3Npb25TdGF0dXMuTElTVEVOSU5HLFxuICAgICAgICBVbHRyYXZveFNlc3Npb25TdGF0dXMuVEhJTktJTkcsXG4gICAgICAgIFVsdHJhdm94U2Vzc2lvblN0YXR1cy5TUEVBS0lORyxcbiAgICBdKTtcbiAgICBfdHJhbnNjcmlwdHMgPSBbXTtcbiAgICBfc3RhdHVzID0gVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkRJU0NPTk5FQ1RFRDtcbiAgICByZWdpc3RlcmVkVG9vbHMgPSBuZXcgTWFwKCk7XG4gICAgc29ja2V0O1xuICAgIHJvb207XG4gICAgYXVkaW9FbGVtZW50ID0gbmV3IEF1ZGlvKCk7XG4gICAgbG9jYWxBdWRpb1RyYWNrO1xuICAgIG1pY1NvdXJjZU5vZGU7XG4gICAgYWdlbnRTb3VyY2VOb2RlO1xuICAgIGRlbGF5ZWRTcGVha2luZ1N0YXRlID0gZmFsc2U7XG4gICAgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGF1ZGlvQ29udGV4dDtcbiAgICBleHBlcmltZW50YWxNZXNzYWdlcztcbiAgICBfaXNNaWNNdXRlZCA9IGZhbHNlO1xuICAgIF9pc1NwZWFrZXJNdXRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBVbHRyYXZveFNlc3Npb24uXG4gICAgICogQHBhcmFtIGF1ZGlvQ29udGV4dCBBbiBBdWRpb0NvbnRleHQgdG8gdXNlIGZvciBhdWRpbyBwcm9jZXNzaW5nLiBJZiBub3QgcHJvdmlkZWQsIGEgbmV3IEF1ZGlvQ29udGV4dCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIGV4cGVyaW1lbnRhbE1lc3NhZ2VzIEEgc2V0IG9mIGV4cGVyaW1lbnRhbCBtZXNzYWdlIHR5cGVzIHRvIGVuYWJsZS4gRW1wdHkgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGF1ZGlvQ29udGV4dCwgZXhwZXJpbWVudGFsTWVzc2FnZXMsIH0gPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dCB8fCBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgICAgIHRoaXMuZXhwZXJpbWVudGFsTWVzc2FnZXMgPSBleHBlcmltZW50YWxNZXNzYWdlcyB8fCBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGFsbCB0cmFuc2NyaXB0cyBmb3IgdGhlIGN1cnJlbnQgc2Vzc2lvbi4gKi9cbiAgICBnZXQgdHJhbnNjcmlwdHMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fdHJhbnNjcmlwdHNdO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgc2Vzc2lvbidzIGN1cnJlbnQgc3RhdHVzLiAqL1xuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyJ3MgbWljIGlzIGN1cnJlbnRseSBtdXRlZCBmb3IgdGhlIHNlc3Npb24uIChEb2VzIG5vdCBpbnNwZWN0XG4gICAgICogaGFyZHdhcmUgc3RhdGUuKVxuICAgICAqL1xuICAgIGdldCBpc01pY011dGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNNaWNNdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIncyBzcGVha2VyIChlLmcuIGFnZW50IG91dHB1dCBhdWRpbykgaXMgY3VycmVudGx5IG11dGVkIGZvciB0aGVcbiAgICAgKiBzZXNzaW9uLiAoRG9lcyBub3QgaW5zcGVjdCBzeXN0ZW0gdm9sdW1lIG9yIGhhcmR3YXJlIHN0YXRlLilcbiAgICAgKi9cbiAgICBnZXQgaXNTcGVha2VyTXV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NwZWFrZXJNdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2xpZW50IHRvb2wgaW1wbGVtZW50YXRpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gSWYgdGhlIGNhbGwgaXNcbiAgICAgKiBzdGFydGVkIHdpdGggYSBjbGllbnQtaW1wbGVtZW50ZWQgdG9vbCwgdGhpcyBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIGludm9rZWRcbiAgICAgKiB3aGVuIHRoZSBtb2RlbCBjYWxscyB0aGUgdG9vbC5cbiAgICAgKlxuICAgICAqIFNlZSBodHRwczovL2RvY3MudWx0cmF2b3guYWkvdG9vbHMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgcmVnaXN0ZXJUb29sSW1wbGVtZW50YXRpb24obmFtZSwgaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkVG9vbHMuc2V0KG5hbWUsIGltcGxlbWVudGF0aW9uKTtcbiAgICB9XG4gICAgLyoqIENvbnZlbmllbmNlIGJhdGNoIHdyYXBwZXIgZm9yIHJlZ2lzdGVyVG9vbEltcGxlbWVudGF0aW9uLiAqL1xuICAgIHJlZ2lzdGVyVG9vbEltcGxlbWVudGF0aW9ucyhpbXBsZW1lbnRhdGlvbk1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBpbXBsZW1lbnRhdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoaW1wbGVtZW50YXRpb25NYXApKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyVG9vbEltcGxlbWVudGF0aW9uKG5hbWUsIGltcGxlbWVudGF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ29ubmVjdHMgdG8gYSBjYWxsIHVzaW5nIHRoZSBnaXZlbiBqb2luVXJsLiAqL1xuICAgIGpvaW5DYWxsKGpvaW5VcmwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyAhPT0gVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgam9pbiBhIG5ldyBjYWxsIHdoaWxlIGFscmVhZHkgaW4gYSBjYWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhwZXJpbWVudGFsTWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoam9pblVybCk7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnZXhwZXJpbWVudGFsTWVzc2FnZXMnLCBBcnJheS5mcm9tKHRoaXMuZXhwZXJpbWVudGFsTWVzc2FnZXMudmFsdWVzKCkpLmpvaW4oJywnKSk7XG4gICAgICAgICAgICBqb2luVXJsID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkNPTk5FQ1RJTkcpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQoam9pblVybCk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVTb2NrZXRNZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVTb2NrZXRDbG9zZShldmVudCk7XG4gICAgfVxuICAgIC8qKiBMZWF2ZXMgdGhlIGN1cnJlbnQgY2FsbCAoaWYgYW55KS4gKi9cbiAgICBhc3luYyBsZWF2ZUNhbGwoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhZ2VudCdzIG91dHB1dCBtZWRpdW0uIElmIHRoZSBhZ2VudCBpcyBjdXJyZW50bHkgc3BlYWtpbmcsIHRoaXMgd2lsbCB0YWtlIGVmZmVjdCBhdFxuICAgICAqIHRoZSBlbmQgb2YgdGhlIGFnZW50J3MgdXR0ZXJhbmNlLiBBbHNvIHNlZSBtdXRlU3BlYWtlciBhbmQgdW5tdXRlU3BlYWtlciBiZWxvdy5cbiAgICAgKi9cbiAgICBzZXRPdXRwdXRNZWRpdW0obWVkaXVtKSB7XG4gICAgICAgIGlmICghVWx0cmF2b3hTZXNzaW9uLkNPTk5FQ1RFRF9TVEFUVVNFUy5oYXModGhpcy5fc3RhdHVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2V0IG91dHB1dCBtZWRpdW0gd2hpbGUgbm90IGNvbm5lY3RlZC4gQ3VycmVudCBzdGF0dXMgaXMgJHt0aGlzLl9zdGF0dXN9LmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZERhdGEoeyB0eXBlOiAnc2V0X291dHB1dF9tZWRpdW0nLCBtZWRpdW0gfSk7XG4gICAgfVxuICAgIC8qKiBTZW5kcyBhIG1lc3NhZ2UgdmlhIHRleHQuICovXG4gICAgc2VuZFRleHQodGV4dCkge1xuICAgICAgICBpZiAoIVVsdHJhdm94U2Vzc2lvbi5DT05ORUNURURfU1RBVFVTRVMuaGFzKHRoaXMuX3N0YXR1cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNlbmQgdGV4dCB3aGlsZSBub3QgY29ubmVjdGVkLiBDdXJyZW50IHN0YXR1cyBpcyAke3RoaXMuX3N0YXR1c30uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kRGF0YSh7IHR5cGU6ICdpbnB1dF90ZXh0X21lc3NhZ2UnLCB0ZXh0IH0pO1xuICAgIH1cbiAgICAvKiogTXV0ZXMgYXVkaW8gaW5wdXQgZnJvbSB0aGUgdXNlci4gKi9cbiAgICBtdXRlTWljKCkge1xuICAgICAgICBpZiAoIXRoaXMucm9vbT8ubG9jYWxQYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbXV0ZU1pYy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc01pY011dGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuc2V0TWljcm9waG9uZUVuYWJsZWQoZmFsc2UpO1xuICAgIH1cbiAgICAvKiogVW5tdXRlcyBhdWRpbyBpbnB1dCBmcm9tIHRoZSB1c2VyLiAqL1xuICAgIHVubXV0ZU1pYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvb20/LmxvY2FsUGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVubXV0ZU1pYy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc01pY011dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LnNldE1pY3JvcGhvbmVFbmFibGVkKHRydWUpO1xuICAgIH1cbiAgICAvKiogVG9nZ2xlcyB0aGUgbXV0ZSBzdGF0ZSBvZiB0aGUgdXNlcidzIGF1ZGlvIGlucHV0LiAqL1xuICAgIHRvZ2dsZU1pY011dGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb29tPy5sb2NhbFBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB0b2dnbGUgbWljIG11dGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNNaWNNdXRlZCkge1xuICAgICAgICAgICAgdGhpcy51bm11dGVNaWMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubXV0ZU1pYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBNdXRlcyBhdWRpbyBvdXRwdXQgZnJvbSB0aGUgYWdlbnQuICovXG4gICAgbXV0ZVNwZWFrZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb29tPy5yZW1vdGVQYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG11dGVTcGVha2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzU3BlYWtlck11dGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb29tLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgcGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHB1YmxpY2F0aW9uLnRyYWNrPy5zZXRNdXRlZCh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFVubXV0ZXMgYXVkaW8gb3V0cHV0IGZyb20gdGhlIGFnZW50LiAqL1xuICAgIHVubXV0ZVNwZWFrZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb29tPy5yZW1vdGVQYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVubXV0ZVNwZWFrZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNTcGVha2VyTXV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb29tLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgcGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHB1YmxpY2F0aW9uLnRyYWNrPy5zZXRNdXRlZChmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBUb2dnbGVzIHRoZSBtdXRlIHN0YXRlIG9mIHRoZSBhZ2VudCdzIG91dHB1dCBhdWRpby4gKi9cbiAgICB0b2dnbGVTcGVha2VyTXV0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvb20/LnJlbW90ZVBhcnRpY2lwYW50cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdG9nZ2xlIHNwZWFrZXIgbXV0ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1NwZWFrZXJNdXRlZCkge1xuICAgICAgICAgICAgdGhpcy51bm11dGVTcGVha2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm11dGVTcGVha2VyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlU29ja2V0TWVzc2FnZShldmVudCkge1xuICAgICAgICBjb25zdCBtc2cgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAvLyBXZSBhdHRhY2ggdGhlIExpdmVraXQgYXVkaW8gdG8gYW4gYXVkaW8gZWxlbWVudCBzbyB0aGF0IHdlIGNhbiBtdXRlIHRoZSBhdWRpb1xuICAgICAgICAvLyB3aGVuIHRoZSBhZ2VudCBpcyBub3Qgc3BlYWtpbmcuIEZvciBub3csIGRpc2FibGUgTGl2ZWtpdCdzIFdlYkF1ZGlvIG1peGluZ1xuICAgICAgICAvLyB0byBhdm9pZCB0aGUgYXVkaW8gcGxheWluZyB0d2ljZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVmZXJlbmNlczpcbiAgICAgICAgLy8gIC0gaHR0cHM6Ly9kb2NzLmxpdmVraXQuaW8vZ3VpZGVzL21pZ3JhdGUtZnJvbS12MS8jSmF2YXNjcmlwdC1UeXBlc2NyaXB0XG4gICAgICAgIC8vICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZla2l0L2NvbXBvbmVudHMtanMvcHVsbC84NTVcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5yb29tID0gbmV3IFJvb20oeyB3ZWJBdWRpb01peDogZmFsc2UgfSk7XG4gICAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCAodHJhY2spID0+IHRoaXMuaGFuZGxlVHJhY2tTdWJzY3JpYmVkKHRyYWNrKSk7XG4gICAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuRGF0YVJlY2VpdmVkLCAocGF5bG9hZCwgcGFydGljaXBhbnQpID0+IHRoaXMuaGFuZGxlRGF0YVJlY2VpdmVkKHBheWxvYWQsIHBhcnRpY2lwYW50KSk7XG4gICAgICAgIGNvbnN0IFt0cmFjaywgX10gPSBhd2FpdCBQcm9taXNlLmFsbChbY3JlYXRlTG9jYWxBdWRpb1RyYWNrKCksIHRoaXMucm9vbS5jb25uZWN0KG1zZy5yb29tVXJsLCBtc2cudG9rZW4pXSk7XG4gICAgICAgIHRoaXMubG9jYWxBdWRpb1RyYWNrID0gdHJhY2s7XG4gICAgICAgIHRoaXMubG9jYWxBdWRpb1RyYWNrLnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgICAgIGlmIChbVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkRJU0NPTk5FQ1RFRCwgVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkRJU0NPTk5FQ1RJTkddLmluY2x1ZGVzKHRoaXMuc3RhdHVzKSkge1xuICAgICAgICAgICAgLy8gV2UndmUgYmVlbiBzdG9wcGVkIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBtaWMgcGVybWlzc2lvbiAoZHVyaW5nIGNyZWF0ZUxvY2FsVHJhY2tzKS5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LnJlc3VtZSgpO1xuICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudC5wbGF5KCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsQXVkaW9UcmFjay5tZWRpYVN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5taWNTb3VyY2VOb2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UodGhpcy5sb2NhbEF1ZGlvVHJhY2subWVkaWFTdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7IG5hbWU6ICdhdWRpbycsIHNpbXVsY2FzdDogZmFsc2UsIHNvdXJjZTogVHJhY2suU291cmNlLk1pY3JvcGhvbmUgfTtcbiAgICAgICAgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRoaXMubG9jYWxBdWRpb1RyYWNrLCBvcHRzKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoVWx0cmF2b3hTZXNzaW9uU3RhdHVzLklETEUpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVTb2NrZXRDbG9zZShldmVudCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkRJU0NPTk5FQ1RJTkcpO1xuICAgICAgICB0aGlzLmxvY2FsQXVkaW9UcmFjaz8uc3RvcCgpO1xuICAgICAgICB0aGlzLmxvY2FsQXVkaW9UcmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgYXdhaXQgdGhpcy5yb29tPy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMucm9vbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zb2NrZXQ/LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1pY1NvdXJjZU5vZGU/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5taWNTb3VyY2VOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmFnZW50U291cmNlTm9kZT8uZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmFnZW50U291cmNlTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkRJU0NPTk5FQ1RFRCk7XG4gICAgfVxuICAgIGhhbmRsZVRyYWNrU3Vic2NyaWJlZCh0cmFjaykge1xuICAgICAgICBjb25zdCBhdWRpb1RyYWNrID0gdHJhY2s7XG4gICAgICAgIGF1ZGlvVHJhY2suYXR0YWNoKHRoaXMuYXVkaW9FbGVtZW50KTtcbiAgICAgICAgaWYgKHRyYWNrLm1lZGlhU3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLmFnZW50U291cmNlTm9kZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHRyYWNrLm1lZGlhU3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxheWVkU3BlYWtpbmdTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWxheWVkU3BlYWtpbmdTdGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoVWx0cmF2b3hTZXNzaW9uU3RhdHVzLlNQRUFLSU5HKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IHN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBVbHRyYXZveFNlc3Npb25TdGF0dXNDaGFuZ2VkRXZlbnQoKSk7XG4gICAgfVxuICAgIHNlbmREYXRhKG9iaikge1xuICAgICAgICB0aGlzLnJvb20/LmxvY2FsUGFydGljaXBhbnQucHVibGlzaERhdGEodGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkob2JqKSksIHsgcmVsaWFibGU6IHRydWUgfSk7XG4gICAgfVxuICAgIGhhbmRsZURhdGFSZWNlaXZlZChwYXlsb2FkLCBfcGFydGljaXBhbnQpIHtcbiAgICAgICAgY29uc3QgbXNnID0gSlNPTi5wYXJzZSh0aGlzLnRleHREZWNvZGVyLmRlY29kZShwYXlsb2FkKSk7XG4gICAgICAgIGlmIChtc2cudHlwZSA9PT0gJ3N0YXRlJykge1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBtc2cuc3RhdGU7XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IFVsdHJhdm94U2Vzc2lvblN0YXR1cy5TUEVBS0lORyAmJiB0aGlzLmFnZW50U291cmNlTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgZmlyc3Qgc3BlYWtpbmcgc3RhdGUsIGJlZm9yZSB3ZSd2ZSBhdHRhY2hlZCB0aGUgYXVkaW8gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGVUcmFja1N1YnNjcmliZWQgd2lsbCBiZSBjYWxsZWQgc29vbiBhbmQgd2lsbCBjaGFuZ2UgdGhlIHN0YXRlLlxuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXllZFNwZWFraW5nU3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMobmV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZy50eXBlID09PSAndHJhbnNjcmlwdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lZGl1bSA9IG1zZy50cmFuc2NyaXB0Lm1lZGl1bSA9PSAndm9pY2UnID8gTWVkaXVtLlZPSUNFIDogTWVkaXVtLlRFWFQ7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IFRyYW5zY3JpcHQobXNnLnRyYW5zY3JpcHQudGV4dCwgbXNnLnRyYW5zY3JpcHQuZmluYWwsIFJvbGUuVVNFUiwgbWVkaXVtKTtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVUcmFuc2NyaXB0KHRyYW5zY3JpcHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZy50eXBlID09PSAndm9pY2Vfc3luY2VkX3RyYW5zY3JpcHQnIHx8IG1zZy50eXBlID09ICdhZ2VudF90ZXh0X3RyYW5zY3JpcHQnKSB7XG4gICAgICAgICAgICBjb25zdCBtZWRpdW0gPSBtc2cudHlwZSA9PSAnYWdlbnRfdGV4dF90cmFuc2NyaXB0JyA/IE1lZGl1bS5URVhUIDogTWVkaXVtLlZPSUNFO1xuICAgICAgICAgICAgaWYgKG1zZy50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUcmFuc2NyaXB0ID0gbmV3IFRyYW5zY3JpcHQobXNnLnRleHQsIG1zZy5maW5hbCwgUm9sZS5BR0VOVCwgbWVkaXVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlVHJhbnNjcmlwdChuZXdUcmFuc2NyaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1zZy5kZWx0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFRyYW5zY3JpcHQgPSB0aGlzLl90cmFuc2NyaXB0cy5sZW5ndGggPyB0aGlzLl90cmFuc2NyaXB0c1t0aGlzLl90cmFuc2NyaXB0cy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRyYW5zY3JpcHQgJiYgbGFzdFRyYW5zY3JpcHQuc3BlYWtlciA9PSBSb2xlLkFHRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RyYW5zY3JpcHQgPSBuZXcgVHJhbnNjcmlwdChsYXN0VHJhbnNjcmlwdC50ZXh0ICsgbXNnLmRlbHRhLCBtc2cuZmluYWwsIFJvbGUuQUdFTlQsIG1lZGl1bSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVUcmFuc2NyaXB0KG5ld1RyYW5zY3JpcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cudHlwZSA9PSAnY2xpZW50X3Rvb2xfaW52b2NhdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuaW52b2tlQ2xpZW50VG9vbChtc2cudG9vbE5hbWUsIG1zZy5pbnZvY2F0aW9uSWQsIG1zZy5wYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmV4cGVyaW1lbnRhbE1lc3NhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFVsdHJhdm94RXhwZXJpbWVudGFsTWVzc2FnZUV2ZW50KG1zZykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZE9yVXBkYXRlVHJhbnNjcmlwdCh0cmFuc2NyaXB0KSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RUcmFuc2NyaXB0ID0gdGhpcy5fdHJhbnNjcmlwdHNbdGhpcy5fdHJhbnNjcmlwdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdFRyYW5zY3JpcHQgJiYgIWxhc3RUcmFuc2NyaXB0LmlzRmluYWwgJiYgdHJhbnNjcmlwdC5zcGVha2VyID09PSBsYXN0VHJhbnNjcmlwdC5zcGVha2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNjcmlwdHNbdGhpcy5fdHJhbnNjcmlwdHMubGVuZ3RoIC0gMV0gPSB0cmFuc2NyaXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNjcmlwdHMucHVzaCh0cmFuc2NyaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zY3JpcHRzLnB1c2godHJhbnNjcmlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBVbHRyYXZveFRyYW5zY3JpcHRzQ2hhbmdlZEV2ZW50KCkpO1xuICAgIH1cbiAgICBpbnZva2VDbGllbnRUb29sKHRvb2xOYW1lLCBpbnZvY2F0aW9uSWQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgdG9vbCA9IHRoaXMucmVnaXN0ZXJlZFRvb2xzLmdldCh0b29sTmFtZSk7XG4gICAgICAgIGlmICghdG9vbCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kRGF0YSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NsaWVudF90b29sX3Jlc3VsdCcsXG4gICAgICAgICAgICAgICAgaW52b2NhdGlvbklkLFxuICAgICAgICAgICAgICAgIGVycm9yVHlwZTogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBgQ2xpZW50IHRvb2wgJHt0b29sTmFtZX0gaXMgbm90IHJlZ2lzdGVyZWQgKFR5cGVTY3JpcHQgY2xpZW50KWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdG9vbChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHRoaXMuaGFuZGxlQ2xpZW50VG9vbFJlc3VsdChpbnZvY2F0aW9uSWQsIHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHRoaXMuaGFuZGxlQ2xpZW50VG9vbEZhaWx1cmUoaW52b2NhdGlvbklkLCBlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGllbnRUb29sUmVzdWx0KGludm9jYXRpb25JZCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGllbnRUb29sRmFpbHVyZShpbnZvY2F0aW9uSWQsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNsaWVudFRvb2xSZXN1bHQoaW52b2NhdGlvbklkLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmREYXRhKHsgdHlwZTogJ2NsaWVudF90b29sX3Jlc3VsdCcsIGludm9jYXRpb25JZCwgcmVzdWx0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0U3RyaW5nID0gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlVHlwZSA9IHJlc3VsdC5yZXNwb25zZVR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFN0cmluZyAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHJlc3BvbnNlVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NsaWVudF90b29sX3Jlc3VsdCcsXG4gICAgICAgICAgICAgICAgICAgIGludm9jYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUeXBlOiAnaW1wbGVtZW50YXRpb24tZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6ICdDbGllbnQgdG9vbCByZXN1bHQgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBvYmplY3Qgd2l0aCBzdHJpbmcgXCJyZXN1bHRcIiBhbmQgXCJyZXNwb25zZVR5cGVcIiBwcm9wZXJ0aWVzLicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmREYXRhKHsgdHlwZTogJ2NsaWVudF90b29sX3Jlc3VsdCcsIGludm9jYXRpb25JZCwgcmVzdWx0OiByZXN1bHRTdHJpbmcsIHJlc3BvbnNlVHlwZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDbGllbnRUb29sRmFpbHVyZShpbnZvY2F0aW9uSWQsIGVycm9yKSB7XG4gICAgICAgIHRoaXMuc2VuZERhdGEoe1xuICAgICAgICAgICAgdHlwZTogJ2NsaWVudF90b29sX3Jlc3VsdCcsXG4gICAgICAgICAgICBpbnZvY2F0aW9uSWQsXG4gICAgICAgICAgICBlcnJvclR5cGU6ICdpbXBsZW1lbnRhdGlvbi1lcnJvcicsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ultravox-client@0.3.2/node_modules/ultravox-client/dist/esm/index.js\n");

/***/ })

};
;